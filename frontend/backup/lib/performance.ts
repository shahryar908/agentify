/**\n * Performance monitoring and optimization utilities\n */\n\n// Performance monitoring class\nexport class PerformanceMonitor {\n  private static instance: PerformanceMonitor\n  private metrics: Map<string, number[]> = new Map()\n  private observers: Map<string, PerformanceObserver> = new Map()\n\n  static getInstance(): PerformanceMonitor {\n    if (!PerformanceMonitor.instance) {\n      PerformanceMonitor.instance = new PerformanceMonitor()\n    }\n    return PerformanceMonitor.instance\n  }\n\n  // Measure API call performance\n  measureApiCall<T>(name: string, apiCall: () => Promise<T>): Promise<T> {\n    const startTime = performance.now()\n    \n    return apiCall().then(\n      (result) => {\n        this.recordMetric(`api_${name}`, performance.now() - startTime)\n        return result\n      },\n      (error) => {\n        this.recordMetric(`api_${name}_error`, performance.now() - startTime)\n        throw error\n      }\n    )\n  }\n\n  // Measure component render time\n  measureRender(componentName: string, renderFn: () => void): void {\n    const startTime = performance.now()\n    renderFn()\n    this.recordMetric(`render_${componentName}`, performance.now() - startTime)\n  }\n\n  // Record custom metrics\n  recordMetric(name: string, value: number): void {\n    if (!this.metrics.has(name)) {\n      this.metrics.set(name, [])\n    }\n    this.metrics.get(name)!.push(value)\n    \n    // Keep only last 100 measurements\n    const values = this.metrics.get(name)!\n    if (values.length > 100) {\n      values.splice(0, values.length - 100)\n    }\n  }\n\n  // Get performance statistics\n  getStats(name: string): {\n    avg: number\n    min: number\n    max: number\n    count: number\n  } | null {\n    const values = this.metrics.get(name)\n    if (!values || values.length === 0) return null\n\n    const avg = values.reduce((sum, val) => sum + val, 0) / values.length\n    const min = Math.min(...values)\n    const max = Math.max(...values)\n\n    return { avg, min, max, count: values.length }\n  }\n\n  // Get all metrics\n  getAllStats(): Record<string, any> {\n    const stats: Record<string, any> = {}\n    \n    for (const [name] of this.metrics) {\n      stats[name] = this.getStats(name)\n    }\n    \n    // Add browser performance metrics if available\n    if (typeof window !== 'undefined' && window.performance) {\n      const navigation = window.performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming\n      if (navigation) {\n        stats.pageLoad = {\n          domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,\n          loadComplete: navigation.loadEventEnd - navigation.loadEventStart,\n          firstPaint: this.getFirstPaint(),\n          firstContentfulPaint: this.getFirstContentfulPaint()\n        }\n      }\n    }\n    \n    return stats\n  }\n\n  private getFirstPaint(): number | null {\n    if (typeof window === 'undefined') return null\n    \n    const paintEntries = window.performance.getEntriesByType('paint')\n    const fp = paintEntries.find(entry => entry.name === 'first-paint')\n    return fp ? fp.startTime : null\n  }\n\n  private getFirstContentfulPaint(): number | null {\n    if (typeof window === 'undefined') return null\n    \n    const paintEntries = window.performance.getEntriesByType('paint')\n    const fcp = paintEntries.find(entry => entry.name === 'first-contentful-paint')\n    return fcp ? fcp.startTime : null\n  }\n\n  // Start observing specific performance entries\n  observePerformance(entryTypes: string[]): void {\n    if (typeof window === 'undefined' || !window.PerformanceObserver) return\n\n    entryTypes.forEach(entryType => {\n      if (this.observers.has(entryType)) return\n\n      try {\n        const observer = new PerformanceObserver((list) => {\n          list.getEntries().forEach(entry => {\n            this.recordMetric(`${entryType}_${entry.name}`, entry.startTime)\n          })\n        })\n        \n        observer.observe({ entryTypes: [entryType] })\n        this.observers.set(entryType, observer)\n      } catch (error) {\n        console.warn(`Failed to observe performance entry type: ${entryType}`, error)\n      }\n    })\n  }\n\n  // Clean up observers\n  disconnect(): void {\n    this.observers.forEach(observer => observer.disconnect())\n    this.observers.clear()\n  }\n}\n\n// React hook for performance monitoring\nimport { useEffect, useRef } from 'react'\n\nexport function usePerformanceMonitor(componentName: string) {\n  const monitor = PerformanceMonitor.getInstance()\n  const renderCount = useRef(0)\n  const startTime = useRef<number>()\n\n  useEffect(() => {\n    startTime.current = performance.now()\n    renderCount.current++\n    \n    return () => {\n      if (startTime.current) {\n        monitor.recordMetric(\n          `component_${componentName}`, \n          performance.now() - startTime.current\n        )\n      }\n    }\n  })\n\n  return {\n    recordMetric: (name: string, value: number) => monitor.recordMetric(name, value),\n    measureApiCall: <T>(name: string, apiCall: () => Promise<T>) => \n      monitor.measureApiCall(name, apiCall),\n    renderCount: renderCount.current\n  }\n}\n\n// Memory usage monitoring\nexport class MemoryMonitor {\n  static getMemoryUsage(): {\n    used: number\n    total: number\n    percentage: number\n  } | null {\n    if (typeof window === 'undefined' || !(window.performance as any).memory) {\n      return null\n    }\n\n    const memory = (window.performance as any).memory\n    return {\n      used: memory.usedJSHeapSize,\n      total: memory.totalJSHeapSize,\n      percentage: (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100\n    }\n  }\n\n  static startMemoryMonitoring(interval: number = 5000): () => void {\n    const monitor = PerformanceMonitor.getInstance()\n    \n    const intervalId = setInterval(() => {\n      const usage = this.getMemoryUsage()\n      if (usage) {\n        monitor.recordMetric('memory_usage', usage.percentage)\n      }\n    }, interval)\n\n    return () => clearInterval(intervalId)\n  }\n}\n\n// Lazy loading utilities\nexport function createLazyComponent<T extends React.ComponentType<any>>(\n  importFn: () => Promise<{ default: T }>\n): React.LazyExoticComponent<T> {\n  return React.lazy(() => {\n    const startTime = performance.now()\n    \n    return importFn().then(module => {\n      PerformanceMonitor.getInstance().recordMetric(\n        'lazy_load_component',\n        performance.now() - startTime\n      )\n      return module\n    })\n  })\n}\n\n// Image optimization utilities\nexport function optimizeImageUrl(\n  src: string, \n  options: {\n    width?: number\n    height?: number\n    quality?: number\n    format?: 'webp' | 'jpeg' | 'png'\n  } = {}\n): string {\n  // This would integrate with your image optimization service\n  // For now, return the original URL\n  return src\n}\n\n// Bundle analyzer helper\nexport function analyzeBundleSize(): void {\n  if (process.env.NODE_ENV === 'development') {\n    console.group('Bundle Analysis')\n    console.log('Performance stats:', PerformanceMonitor.getInstance().getAllStats())\n    console.log('Memory usage:', MemoryMonitor.getMemoryUsage())\n    console.groupEnd()\n  }\n}\n\n// Initialize performance monitoring\nexport function initPerformanceMonitoring(): void {\n  if (typeof window === 'undefined') return\n\n  const monitor = PerformanceMonitor.getInstance()\n  \n  // Observe key performance metrics\n  monitor.observePerformance(['paint', 'navigation', 'measure'])\n  \n  // Start memory monitoring\n  MemoryMonitor.startMemoryMonitoring()\n  \n  // Log performance data in development\n  if (process.env.NODE_ENV === 'development') {\n    setTimeout(() => {\n      console.group('Performance Metrics')\n      console.table(monitor.getAllStats())\n      console.groupEnd()\n    }, 3000)\n  }\n}\n\nimport React from 'react'\n\n// Export singleton instance\nexport const performanceMonitor = PerformanceMonitor.getInstance()"