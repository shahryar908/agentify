/**\n * Advanced caching system for API responses and data\n */\n\ninterface CacheEntry<T> {\n  data: T\n  timestamp: number\n  ttl: number // Time to live in milliseconds\n  version?: string\n}\n\ninterface CacheOptions {\n  ttl?: number // Default 5 minutes\n  version?: string\n  storage?: 'memory' | 'localStorage' | 'sessionStorage'\n  maxSize?: number // Maximum number of entries\n}\n\nclass CacheManager {\n  private memoryCache = new Map<string, CacheEntry<any>>()\n  private readonly DEFAULT_TTL = 5 * 60 * 1000 // 5 minutes\n  private readonly MAX_MEMORY_SIZE = 100\n\n  // Get cached data\n  get<T>(\n    key: string, \n    options: CacheOptions = {}\n  ): T | null {\n    const storage = options.storage || 'memory'\n    const entry = this.getEntry<T>(key, storage)\n    \n    if (!entry) return null\n    \n    // Check if entry has expired\n    if (Date.now() - entry.timestamp > entry.ttl) {\n      this.delete(key, storage)\n      return null\n    }\n    \n    // Check version compatibility\n    if (options.version && entry.version !== options.version) {\n      this.delete(key, storage)\n      return null\n    }\n    \n    return entry.data\n  }\n\n  // Set cached data\n  set<T>(\n    key: string, \n    data: T, \n    options: CacheOptions = {}\n  ): void {\n    const storage = options.storage || 'memory'\n    const ttl = options.ttl || this.DEFAULT_TTL\n    \n    const entry: CacheEntry<T> = {\n      data,\n      timestamp: Date.now(),\n      ttl,\n      version: options.version\n    }\n    \n    if (storage === 'memory') {\n      // Implement LRU cache for memory storage\n      if (this.memoryCache.size >= (options.maxSize || this.MAX_MEMORY_SIZE)) {\n        const oldestKey = this.memoryCache.keys().next().value\n        this.memoryCache.delete(oldestKey)\n      }\n      this.memoryCache.set(key, entry)\n    } else {\n      try {\n        const storageObj = storage === 'localStorage' ? localStorage : sessionStorage\n        storageObj.setItem(`cache_${key}`, JSON.stringify(entry))\n      } catch (error) {\n        console.warn('Failed to store in browser storage:', error)\n        // Fallback to memory cache\n        this.memoryCache.set(key, entry)\n      }\n    }\n  }\n\n  // Delete cached entry\n  delete(key: string, storage: 'memory' | 'localStorage' | 'sessionStorage' = 'memory'): void {\n    if (storage === 'memory') {\n      this.memoryCache.delete(key)\n    } else {\n      try {\n        const storageObj = storage === 'localStorage' ? localStorage : sessionStorage\n        storageObj.removeItem(`cache_${key}`)\n      } catch (error) {\n        console.warn('Failed to delete from browser storage:', error)\n      }\n    }\n  }\n\n  // Clear all cache\n  clear(storage: 'memory' | 'localStorage' | 'sessionStorage' | 'all' = 'all'): void {\n    if (storage === 'all' || storage === 'memory') {\n      this.memoryCache.clear()\n    }\n    \n    if (storage === 'all' || storage === 'localStorage') {\n      this.clearBrowserStorage(localStorage)\n    }\n    \n    if (storage === 'all' || storage === 'sessionStorage') {\n      this.clearBrowserStorage(sessionStorage)\n    }\n  }\n\n  private getEntry<T>(key: string, storage: string): CacheEntry<T> | null {\n    if (storage === 'memory') {\n      return this.memoryCache.get(key) || null\n    }\n    \n    try {\n      const storageObj = storage === 'localStorage' ? localStorage : sessionStorage\n      const cached = storageObj.getItem(`cache_${key}`)\n      return cached ? JSON.parse(cached) : null\n    } catch (error) {\n      console.warn('Failed to retrieve from browser storage:', error)\n      return null\n    }\n  }\n\n  private clearBrowserStorage(storage: Storage): void {\n    try {\n      const keysToRemove: string[] = []\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i)\n        if (key?.startsWith('cache_')) {\n          keysToRemove.push(key)\n        }\n      }\n      keysToRemove.forEach(key => storage.removeItem(key))\n    } catch (error) {\n      console.warn('Failed to clear browser storage:', error)\n    }\n  }\n\n  // Get cache statistics\n  getStats(): {\n    memorySize: number\n    localStorageSize: number\n    sessionStorageSize: number\n  } {\n    let localStorageSize = 0\n    let sessionStorageSize = 0\n    \n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i)\n        if (key?.startsWith('cache_')) localStorageSize++\n      }\n      \n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i)\n        if (key?.startsWith('cache_')) sessionStorageSize++\n      }\n    } catch (error) {\n      console.warn('Failed to get storage stats:', error)\n    }\n    \n    return {\n      memorySize: this.memoryCache.size,\n      localStorageSize,\n      sessionStorageSize\n    }\n  }\n}\n\n// Singleton cache manager\nexport const cacheManager = new CacheManager()\n\n// React hook for cached API calls\nimport { useState, useEffect, useCallback } from 'react'\nimport { performanceMonitor } from './performance'\n\ninterface UseCacheOptions<T> extends CacheOptions {\n  enabled?: boolean\n  onError?: (error: Error) => void\n  onSuccess?: (data: T) => void\n}\n\nexport function useCache<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n  options: UseCacheOptions<T> = {}\n) {\n  const [data, setData] = useState<T | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<Error | null>(null)\n  const [lastFetch, setLastFetch] = useState<number>(0)\n\n  const fetchData = useCallback(async (force = false) => {\n    if (!options.enabled && options.enabled !== undefined) return\n    \n    // Check cache first unless forced\n    if (!force) {\n      const cached = cacheManager.get<T>(key, options)\n      if (cached) {\n        setData(cached)\n        setError(null)\n        return cached\n      }\n    }\n    \n    setIsLoading(true)\n    setError(null)\n    \n    try {\n      const result = await performanceMonitor.measureApiCall(key, fetcher)\n      \n      // Cache the result\n      cacheManager.set(key, result, options)\n      \n      setData(result)\n      setLastFetch(Date.now())\n      \n      options.onSuccess?.(result)\n      return result\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error')\n      setError(error)\n      options.onError?.(error)\n      throw error\n    } finally {\n      setIsLoading(false)\n    }\n  }, [key, fetcher, options])\n\n  const invalidate = useCallback(() => {\n    cacheManager.delete(key, options.storage)\n    setData(null)\n    setLastFetch(0)\n  }, [key, options.storage])\n\n  const refresh = useCallback(() => {\n    return fetchData(true)\n  }, [fetchData])\n\n  useEffect(() => {\n    fetchData()\n  }, [fetchData])\n\n  return {\n    data,\n    isLoading,\n    error,\n    lastFetch,\n    refetch: fetchData,\n    refresh,\n    invalidate\n  }\n}\n\n// Cached API client wrapper\nexport function withCache<T extends (...args: any[]) => Promise<any>>(\n  fn: T,\n  generateKey: (...args: Parameters<T>) => string,\n  options: CacheOptions = {}\n): T {\n  return (async (...args: Parameters<T>) => {\n    const key = generateKey(...args)\n    \n    // Check cache first\n    const cached = cacheManager.get(key, options)\n    if (cached) {\n      return cached\n    }\n    \n    // Execute function and cache result\n    const result = await fn(...args)\n    cacheManager.set(key, result, options)\n    \n    return result\n  }) as T\n}\n\n// Cache invalidation patterns\nexport class CacheInvalidator {\n  private patterns = new Map<string, RegExp>()\n  \n  addPattern(name: string, pattern: RegExp): void {\n    this.patterns.set(name, pattern)\n  }\n  \n  invalidatePattern(name: string): void {\n    const pattern = this.patterns.get(name)\n    if (!pattern) return\n    \n    // Clear matching memory cache entries\n    const memoryKeys = Array.from(cacheManager['memoryCache'].keys())\n    memoryKeys.forEach(key => {\n      if (pattern.test(key)) {\n        cacheManager.delete(key, 'memory')\n      }\n    })\n    \n    // Clear matching browser storage entries\n    this.clearStoragePattern(localStorage, pattern)\n    this.clearStoragePattern(sessionStorage, pattern)\n  }\n  \n  private clearStoragePattern(storage: Storage, pattern: RegExp): void {\n    try {\n      const keysToRemove: string[] = []\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i)\n        if (key?.startsWith('cache_') && pattern.test(key.substring(6))) {\n          keysToRemove.push(key)\n        }\n      }\n      keysToRemove.forEach(key => storage.removeItem(key))\n    } catch (error) {\n      console.warn('Failed to clear storage pattern:', error)\n    }\n  }\n}\n\nexport const cacheInvalidator = new CacheInvalidator()\n\n// Setup common cache invalidation patterns\ncacheInvalidator.addPattern('agents', /^agents/)\ncacheInvalidator.addPattern('chat', /^chat/)\ncacheInvalidator.addPattern('blogs', /^blogs/)\ncacheInvalidator.addPattern('user', /^user/)\n\n// Auto-cleanup expired entries\nsetInterval(() => {\n  const stats = cacheManager.getStats()\n  if (stats.memorySize > 50) { // If memory cache is getting large\n    // Force cleanup by attempting to access all entries\n    // Expired entries will be automatically removed\n    const keys = Array.from(cacheManager['memoryCache'].keys())\n    keys.forEach(key => cacheManager.get(key))\n  }\n}, 60000) // Check every minute"